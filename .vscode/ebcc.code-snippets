{
  "ebcc": {
    "scope": "",
    "prefix": "ebcc",
    "body": [
      "struct EBCC {\n    int n;\n    vector<vector<int>> adj;\n    vector<int> stk;\n    vector<int> dfn, low, bel;\n    int cur, cnt;\n    \n    EBCC() {}\n    EBCC(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        this->n = n;\n        adj.assign(n, {});\n        dfn.assign(n, -1); // dfs tree visit time (not distance from root)\n        low.resize(n); //the value of the lowest entry node any descendent or itself can reach through a backedge\n        bel.assign(n, -1);\n        stk.clear();\n        cur = cnt = 0;\n    }\n    \n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    void dfs(int x, int p) {\n        dfn[x] = low[x] = cur++;\n        stk.push_back(x);\n        \n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            if (dfn[y] == -1) {\n                dfs(y, x);\n                low[x] = min(low[x], low[y]);\n            } else if (bel[y] == -1) {\n                low[x] = min(low[x], dfn[y]);\n            }\n        }\n        \n        if (dfn[x] == low[x]) {\n            int y;\n            do {\n                y = stk.back();\n                bel[y] = cnt;\n                stk.pop_back();\n            } while (y != x);\n            cnt++;\n        }\n    }\n    \n    vector<int> work() { // runs a dfs with tarjan's bridge algorithm and returns the labels of each node\n        dfs(0, -1);\n        return bel;\n    }\n    \n    struct Graph {\n        int n;\n        vector<pair<int, int>> edges;\n        vector<int> siz;\n        vector<int> cnte;\n    };\n    Graph compress() { // returns a tree with nodes representing a biconnected componet, siz is the size of such component and cnte is number of edges in such component\n        Graph g;\n        g.n = cnt;\n        g.siz.resize(cnt);\n        g.cnte.resize(cnt);\n        for (int i = 0; i < n; i++) {\n            g.siz[bel[i]]++;\n            for (auto j : adj[i]) {\n                if (bel[i] < bel[j]) {\n                    g.edges.emplace_back(bel[i], bel[j]);\n                } else if (i < j) {\n                    g.cnte[bel[i]]++;\n                }\n            }\n        }\n        return g;\n    }\n};"
    ],
    "description": ""
  }
}